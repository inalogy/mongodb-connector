package com.inalogy.midpoint.connectors.schema;

import com.inalogy.midpoint.connectors.mongodb.MongoDbConfiguration;
import com.inalogy.midpoint.connectors.utils.Constants;
import org.bson.Document;
import org.identityconnectors.framework.common.objects.AttributeBuilder;
import org.identityconnectors.framework.common.objects.AttributeInfo;
import org.identityconnectors.framework.common.objects.AttributeInfoBuilder;
import org.identityconnectors.framework.common.objects.ConnectorObject;
import org.identityconnectors.framework.common.objects.ConnectorObjectBuilder;
import org.identityconnectors.framework.common.objects.Name;
import org.identityconnectors.framework.common.objects.ObjectClass;
import org.identityconnectors.framework.common.objects.ObjectClassInfo;
import org.identityconnectors.framework.common.objects.ObjectClassInfoBuilder;
import org.identityconnectors.framework.common.objects.ObjectClassUtil;
import org.identityconnectors.framework.common.objects.OperationalAttributeInfos;
import org.identityconnectors.framework.common.objects.Schema;
import org.identityconnectors.framework.common.objects.SchemaBuilder;
import org.identityconnectors.framework.common.objects.Uid;

import java.util.ArrayList;
import java.util.Base64;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;

import static com.inalogy.midpoint.connectors.utils.Constants.ICFS_NAME;
import static com.inalogy.midpoint.connectors.utils.Constants.ICFS_PASSWORD;

/**
 * Utility class for handling the schema-related functionalities in the MongoDB connector.
 * <p>
 * This class is responsible for creating ObjectClass schemas, building attributes,
 * and converting MongoDB Documents into ConnectorObjects.
 * </p>
 *
 * @author P-Rovnak
 * @version 1.0
 */
public class SchemaHandler {
    public static final String ACCOUNT_NAME = ObjectClassUtil.createSpecialName("ACCOUNT");


    /**
     * Builds the ObjectClass schema for account objects.
     *
     * @param schemaBuilder  The schema builder to which the ObjectClass definition will be added.
     * @param keyColumn      The column used as the unique identifier for the ObjectClass.
     * @param passwordColumn The column used for storing passwords.
     * @param templateUser   A MongoDB Document that serves as a template for the ObjectClass.
     */
    public static void buildObjectClass(SchemaBuilder schemaBuilder, String keyColumn, String passwordColumn, Document templateUser) {
        ObjectClassInfoBuilder objClassBuilder = new ObjectClassInfoBuilder();
        objClassBuilder.setType(ACCOUNT_NAME);
        Set<AttributeInfo> attributeInfos = buildAttributeInfoSet(templateUser, keyColumn, passwordColumn);
        objClassBuilder.addAllAttributeInfo(attributeInfos);

        schemaBuilder.defineObjectClass(objClassBuilder.build());
    }


    /**
     * Builds a set of AttributeInfo objects based on the attributes present in a MongoDB document.
     * <p>
     * This method iterates through the key-value pairs in the template MongoDB Document and creates
     * AttributeInfo objects based on the types and values. Special handling is done for key and password columns.
     * </p>
     *
     * @param templateUser   The MongoDB Document that serves as a template for creating AttributeInfo objects.
     * @param keyColumn      The column used as the unique identifier for the ObjectClass.
     * @param passwordColumn The column used for storing passwords.
     * @return               A Set of AttributeInfo objects.
     */
    private static Set<AttributeInfo> buildAttributeInfoSet(Document templateUser, String keyColumn, String passwordColumn) {
        Set<AttributeInfo> attrInfo = new HashSet<>();
        SimpleDateFormat sdf = new SimpleDateFormat(Constants.ISO_DATE_FORMAT);
        sdf.setTimeZone(TimeZone.getTimeZone(Constants.TIME_ZONE));

        for (Map.Entry<String, Object> entry : templateUser.entrySet()) {
            String name = entry.getKey();
            Object value = entry.getValue();

            if (value instanceof org.bson.types.ObjectId) {
                value = value.toString();
            }

            if (value instanceof Date) {
                value = sdf.format((Date) value);
            }


            AttributeInfoBuilder attrBld = new AttributeInfoBuilder();

            if (name.equalsIgnoreCase(Constants.MONGODB_UID)) {
                attrBld.setName(Uid.NAME);
                attrBld.setRequired(false);  // Its generated by database
                attrBld.setUpdateable(false);
                attrInfo.add(attrBld.build());
            } else if (name.equalsIgnoreCase(keyColumn)) {
                attrBld.setName(Name.NAME);
                attrBld.setRequired(true);
                attrInfo.add(attrBld.build());
            } else if (name.equalsIgnoreCase(passwordColumn)) {
                attrInfo.add(OperationalAttributeInfos.PASSWORD);
            } else {
                Class<?> dataType = value != null ? value.getClass() : String.class; //  String.class as a default type for null values

                // Check for multi-valued attributes
                if (value instanceof List || value instanceof Set) {
                    attrBld.setMultiValued(true);
                    dataType = ((Collection<?>) value).isEmpty() ? String.class : ((Collection<?>) value).iterator().next().getClass();
                }

                attrBld.setType(dataType);
                attrBld.setName(name);
                attrBld.setRequired(false);
                attrBld.setReturnedByDefault(true); //every attr returned by default
                attrInfo.add(attrBld.build());
            }
        }
        return attrInfo;
    }

    /**
     * Converts a MongoDB Document to a ConnectorObject.
     *
     * @param document       The MongoDB Document to convert.
     * @param schema         The schema used for the conversion.
     * @param objectClass    The ObjectClass type for the resulting ConnectorObject.
     * @param templateUser   A MongoDB Document that serves as a template for the ObjectClass.
     * @param configuration  The MongoDB Configuration.
     * @return               A ConnectorObject built from the MongoDB Document.
     */
    public static ConnectorObject convertDocumentToConnectorObject(Document document, Schema schema, ObjectClass objectClass, Document templateUser, MongoDbConfiguration configuration) {
        ConnectorObjectBuilder builder = new ConnectorObjectBuilder();

        builder.setObjectClass(objectClass);
        ObjectClassInfo oci = schema.findObjectClassInfo(objectClass.getObjectClassValue());

        if (oci == null) {
            throw new IllegalArgumentException("ObjectClass not found in schema: " + objectClass.getObjectClassValue());
        }

        // Extract the AttributeInfo set for the ObjectClass
        Set<AttributeInfo> attributeInfos = oci.getAttributeInfo();

        for (Map.Entry<String, Object> entry : document.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();

            //
            if (value instanceof Date) {
                value = value.toString();
            }

            if (entry.getKey().equals(Constants.MONGODB_UID)){
                builder.setUid(new Uid(value.toString()));
                continue;
            }
            if (entry.getKey().equals(configuration.getKeyColumn())){
                builder.setName(new Name(value.toString()));
                continue;
            }

            Optional<AttributeInfo> attributeInfoOpt = attributeInfos.stream()
                    .filter(attrInfo -> attrInfo.getName().equalsIgnoreCase(key))
                    .findFirst();

            if (attributeInfoOpt.isPresent()) {
                AttributeInfo attributeInfo = attributeInfoOpt.get();
                if (attributeInfo.isMultiValued() && value instanceof List) {
                    builder.addAttribute(AttributeBuilder.build(key, (List<?>) value));
                } else {
                    builder.addAttribute(AttributeBuilder.build(key, value));
                }
            }
        }

        return builder.build();
    }

    /**
     * Aligns the data types of a MongoDB Document to match those of a template Document.
     *
     * @param docToInsert    The MongoDB Document whose types need to be aligned.
     * @param templateUser   The template Document against which to align types.
     * @param configuration  The MongoDB Configuration.
     * @return               A new MongoDB Document with aligned types.
     */
    public static Document alignDataTypes(Document docToInsert, Document templateUser, MongoDbConfiguration configuration) {
        Document alignedDocument = new Document();

        for (Map.Entry<String, Object> entry : docToInsert.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();
            Object templateValue = templateUser.get(key);

            // if attr not present in templateUser it must be __SPECIAL_ATTR
            if (templateValue == null) {
                templateValue = templateUser.get(key);

                switch (key) {
                    case ICFS_NAME:
                        key = configuration.getKeyColumn();
                        break;
//                    case ICFS_UID:
//                        key = Constants.MONGODB_UID;
//                        break;
                    case ICFS_PASSWORD:
                        key = configuration.getPasswordColumnName();
                        break;
                    default:
                        //    TODO err handling
                        break;
                }
            }

            if (templateValue != null) {
                Class<?> templateType = templateValue.getClass();
//              handle multivalue attribute (one-dimensional array) all attributes inside must be strings
                if (templateValue instanceof List) {
                    List<?> templateList = (List<?>) templateValue;
                    if (!templateList.isEmpty()) {
                        templateType = templateList.get(0).getClass();
                    }
                    List<Object> newValueList = new ArrayList<>();

                    if (value instanceof List) {
                        for (Object item : (List<?>) value) {
                            newValueList.add(convertValue(item, templateType));
                        }
                    } else {
                        newValueList.add(convertValue(value, templateType));
                    }

                    alignedDocument.append(key, newValueList);
                } else {
                    //handle any other data type
                    alignedDocument.append(key, convertValue(value, templateType));
                }
            } else {
                alignedDocument.append(key, value);
            }
        }

        return alignedDocument;
    }

    private static Object convertValue(Object value, Class<?> targetType) {
        if (targetType.equals(String.class)) {
            return value.toString();
        } else if (targetType.equals(Integer.class)) {
            return Integer.parseInt(value.toString());
        } else if (targetType.equals(Long.class)) {
            return Long.parseLong(value.toString());
        } else if (targetType.equals(Double.class)) {
            return Double.parseDouble(value.toString());
        } else if (targetType.equals(Date.class)) {
//            SimpleDateFormat sdf = new SimpleDateFormat(Constants.ISO_DATE_FORMAT);
            try {
                return new Date(Date.parse(value.toString()));
            } catch (Exception e) { // Catching runtime exceptions
                //FIXME: add logging for errors
                return null;
            }

        } else if (targetType.equals(byte[].class)) {
            // Assuming the photo is Base64 encoded
            return Base64.getDecoder().decode(value.toString());
        } else if (targetType.equals(Boolean.class)) {
            return Boolean.parseBoolean(value.toString());
        } else {
            return value;
        }
    }
}
